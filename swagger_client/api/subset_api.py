# coding: utf-8

"""
    Fonts API

    Everything Fonts Font API gives you API access to fonts, font properties and font tools. You can get all the details about font upto the individual glyph level and do amazing things with it. This is a first of its kind on the cloud. Font conversion API allows you to easily convert between various font formats using REST API. ttf,otf,svg,pfa,pfb, svg, woff,woff2, eot, ufo and several other formats are supported. Here are the individual API links:    ## Font Management API ##   All the things you need to manage a font on the cloud. [Click here to subscribe](https://everythingfonts.com/api/font)   ## @font-face generation API ##   Easily generate @font-face kit from variety of font formats. This service lets you generate ttf, otf, svg and woff formats that the browsers understand along with the relevant CSS definition. [Click here to subscribe](https://everythingfonts.com/api/ffgen)    ## Font Coversion API ##   Convert from one font format to another. Many many font format conversions are supported. [Click here to subscribe](https://everythingfonts.com/api/convert)   ## Font Subsetting API ##   Subset fonts easily. You can specify unicode range or individual characters for subsettings. [Click here to subscribe](https://everythingfonts.com/api/subset)   ## Font Hinting API ##   Font hinting on the cloud. Multiple hinting schemes supported. [Click here to subscribe](https://everythingfonts.com/api/hinting)   # noqa: E501

    OpenAPI spec version: 2.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class SubsetApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def font_id_subset_get(self, id, glyphs, **kwargs):  # noqa: E501
        """font_id_subset_get  # noqa: E501

        Subset the font and download the result.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.font_id_subset_get(id, glyphs, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Font ID (required)
        :param str glyphs: Comma seperated glyph ranges or single glyphs. e.g 0x61-0x7A,0x30-0x39 (required)
        :param bool use_cssrange: Affects how the custom_glyphs string is processed. Default is set to false.
        :param str custom_glyphs: A literal string whose value will be converted to unicode values. If the paramater use_cssrange is set to true this will be treated as CSS unicode ranges.
        :param bool binaryresult: Return converted file in binary format, the default is base64 json response.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.font_id_subset_get_with_http_info(id, glyphs, **kwargs)  # noqa: E501
        else:
            (data) = self.font_id_subset_get_with_http_info(id, glyphs, **kwargs)  # noqa: E501
            return data

    def font_id_subset_get_with_http_info(self, id, glyphs, **kwargs):  # noqa: E501
        """font_id_subset_get  # noqa: E501

        Subset the font and download the result.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.font_id_subset_get_with_http_info(id, glyphs, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Font ID (required)
        :param str glyphs: Comma seperated glyph ranges or single glyphs. e.g 0x61-0x7A,0x30-0x39 (required)
        :param bool use_cssrange: Affects how the custom_glyphs string is processed. Default is set to false.
        :param str custom_glyphs: A literal string whose value will be converted to unicode values. If the paramater use_cssrange is set to true this will be treated as CSS unicode ranges.
        :param bool binaryresult: Return converted file in binary format, the default is base64 json response.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'glyphs', 'use_cssrange', 'custom_glyphs', 'binaryresult']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method font_id_subset_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `font_id_subset_get`")  # noqa: E501
        # verify the required parameter 'glyphs' is set
        if ('glyphs' not in params or
                params['glyphs'] is None):
            raise ValueError("Missing the required parameter `glyphs` when calling `font_id_subset_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'glyphs' in params:
            query_params.append(('glyphs', params['glyphs']))  # noqa: E501
        if 'use_cssrange' in params:
            query_params.append(('use_cssrange', params['use_cssrange']))  # noqa: E501
        if 'custom_glyphs' in params:
            query_params.append(('custom_glyphs', params['custom_glyphs']))  # noqa: E501
        if 'binaryresult' in params:
            query_params.append(('binaryresult', params['binaryresult']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['X-EverythingFonts-Api-Secret']  # noqa: E501

        return self.api_client.call_api(
            '/font/{id}/subset', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def font_subset_ranges_get(self, **kwargs):  # noqa: E501
        """font_subset_ranges_get  # noqa: E501

        Get the subset unicode ranges.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.font_subset_ranges_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.font_subset_ranges_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.font_subset_ranges_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def font_subset_ranges_get_with_http_info(self, **kwargs):  # noqa: E501
        """font_subset_ranges_get  # noqa: E501

        Get the subset unicode ranges.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.font_subset_ranges_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method font_subset_ranges_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['X-EverythingFonts-Api-Secret']  # noqa: E501

        return self.api_client.call_api(
            '/font/subset/ranges', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
